import re
import datetime
from typing import Callable, Optional

class CheckDuplicate():    
    """It aims to avoid duplication in the JSON/CASE file generated by the parsers (UFED, AXIOM etc.)
    """    
    
    def check_value(self, *args: tuple[str, ...], value: str, list_values: list[str], 
            list_objects: list[dict], observable_generating_f: Callable[..., dict]) -> dict:
        """It checks if a specific value has been already generated related to an ObservableObject relying on
        the list of its values. This is meant to avoid duplication in the JSON/CASE file generated by the
        parsers (UFED, AXIOM etc.).
        If the value is not in the list_values, a new ObservableObject is generated by using  the function
        observable_generating_f that returns, as a result, the new ObservableObject (e.g. uco-observable:ApplicationFacet,
        uco-observable:AccountFacet, uco-location:LatLongCoordinatesFacet: drafting:SearchedItemFacet, "uco-observable:URLFacet,
        uco-observable:ApplicationAccountFacet, uco-observable:DigitalAccountFacet, uco-observable:PhoneAccountFacet).
        
        Finally the new ObservableObject is added to the list_objects (any kind of ObservableObject maintains a different list).
        If the value is already in the list_values, the ObservableObject list_objects[index] is returned.
        
        :param value: the value to be checked within the list_values
        :param list_values: the current list of values
        :param list_objects: the current list of a specific kind of ObservableObject
        :param observable_generating_f: the function that will generate the corresponding kind of ObservableObject
        :param *args: the actual parameter of the observable_generating_f function
        :return: an Observableobject of a specific kind depending by the actual parameters
        """        
        if value in list_values:
            idx = list_values.index(value)            
            observable_app = list_objects[idx]
        else:            
            observable_app = observable_generating_f(*args)
            list_values.append(value)
            list_objects.append(observable_app)
            
        return observable_app
    
class AdjustDate():    
    """It amends the data to either make it homogeneous or get rid of some dirty chracters extracted from the XML reports.
    """      
    def uniform_date(self, original_date: str) -> Optional[datetime.date]:
        """
        Amend the original date to convert it into a uniform format. The xsd:dateTime will have the format
        YYYY-MM-DDTHH:MM:SS(+HH:MM).
        """
        aMonths = {
            'Jan': '01',
            'Feb': '02',
            'Mar': '03',
            'Apr': '04',
            'May': '05',
            'Jun': '06',
            'Jul': '07',
            'Aug': '08',
            'Sep': '09',
            'Oct': '10',
            'Nov': '11',
            'Dec': '12'
        }
        
        chars_to_replace = {
            "/" : "-",
            "(" : "-",
            ")" :  "-", 
            'UTC':  '',
            'AM': '',
            'PM': ''
        }
            
        original_date = original_date.strip()
    
        if 	original_date == '':
            return None
    
        for k,v in aMonths.items():
            if original_date.find(k) > -1:
                original_date = original_date.replace(k, v)
                break
        for k,v in chars_to_replace.items():
            original_date = original_date.replace(k, v)
    
        original_date = original_date.replace(' ', 'T', 1)

        if re.search('^[0-9]{4}', original_date):
            pass
        else:
            # when uniform_date is in Italian formato and the Year is placed before 'T' and 
            # composed of two digits, i.e. Year=YY
            original_date = re.sub('-([0-9][0-9])T', '-20\g<1>T', original_date)
            original_date = str(original_date[6:10]) + original_date[2:6] + original_date[0:2] + \
                                original_date[10:] 
    
        # the code is for correctly processing the R-CSAM-E11-UFED-Samsung-Galaxy.xml report
        start_tz = original_date.find("+")
        if start_tz > -1:            
            original_date = original_date[:start_tz]

    
        date_chars = original_date[:10] # YYYY-MM-DD
        date_chars = date_chars.replace(".", "-")
        original_date = date_chars + original_date[10:]
    
        # as above the code is for the R-CSAM-E11-UFED-Samsung-Galaxy.xml report
        if original_date[-1] == '-':
            original_date = original_date[0:-1]
    
        original_date = original_date.replace('.000', '').replace('.', ':')
    
        original_date = original_date.replace('.', ':')

        if re.search('T\d{2}\.', original_date):
            original_date = original_date.replace('.', ':')
    
        if re.search('(\d{2}:\d{2}:\d{2})$', original_date):
            pass
        else:
            original_date = re.sub('(\d{2}:\d{2})$', '\g<1>:00', original_date)
    
        if re.search('T(\d):', original_date):
            original_date = re.sub('T(\d):', 'T0\g<1>:', original_date)
    
        if re.search(':(\d)', original_date):
            original_date = re.sub(':(\d):', ':0\g<1>', original_date)
        
        if re.search('T\d{2}:\d{2}:\d{2}(.+)$', original_date):
            original_date = re.sub('(T\d{2}:\d{2}:\d{2})(.+)$', '\g<1>', original_date)
    
    
        if original_date.find('+') > -1:
            uniform_date = datetime.datetime.strptime(original_date, 
                                                        '%Y-%m-%dT%H:%M:%S.%f%z')
        else:
            uniform_date = datetime.datetime.strptime(original_date,
                                                        '%Y-%m-%dT%H:%M:%S')
    
        return uniform_date
    